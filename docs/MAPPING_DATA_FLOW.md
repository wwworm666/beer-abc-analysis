# 🔗 Как работает синхронизация названий КЕГ ↔ ПОРЦИИ

## 📍 Проблема: Разные системы используют разные имена

### iiko система (Инвентарь)
Кеги хранятся как **товары в инвентаре**:
```
КЕГ Brewlok IPA 20 л          (товар в iiko)
КЕГ ФестХаус Хеллес 30 л      (товар в iiko)
КЕГ Блек Шип 50 л              (товар в iiko)
```

### POS система (Меню/Чеки)
Но в меню они называются **по-другому**:
```
Brewlok IPA (0,5)              (позиция в меню)
Brewlok IPA (0,25)             (другой размер)
ВО Brewlok IPA (0,5)           (вариант с префиксом)
Brewlok IPA                     (без объёма в чеке)
```

### ❓ Как соединить эти два мира?

**Ответ:** Система мэппинга! 🗺️

---

## 🗺️ Архитектура синхронизации

```
                    ФИЗИЧЕСКИЙ МИР
                      (Складские кеги)
                            |
                            v
                    ┌─────────────────┐
                    │  iiko Inventory │
                    │ (товары/SKU)    │
                    └────────┬────────┘
                             |
        ┌────────────────────┼────────────────────┐
        |                    |                    |
        | (Кеги как товары)  | (Фильтр)           | (Только активные)
        v                    v                    v
    ┌──────────────────────────────────────────┐
    │ CSV: active_dishes_to_kegs_CLEAN.csv     │
    │ (Исходный источник истины)               │
    └────────┬─────────────────────────────────┘
             |
    ┌────────┴─────────────────────────────────┐
    │   utils/import_final_mapping.py           │
    │   (Парсит CSV и генерирует коды)         │
    └────────┬─────────────────────────────────┘
             |
    ┌────────┴──────────────────────┬──────────────────────┐
    |                               |                      |
    v                               v                      v
┌─────────────────────┐   ┌──────────────────┐   ┌────────────────────┐
│ mapping/            │   │ data/            │   │ data/              │
│ keg_mapping.py      │   │ keg_mapping.json │   │ dish_to_keg_...json│
│                     │   │                  │   │                    │
│ KEG_TO_DISH_MAPPING │   │ JSON format      │   │ REVERSE mapping    │
│ (Python dict)       │   │ {keg: [dishes]}  │   │ {dish: keg}        │
└─────────┬───────────┘   └──────────────────┘   └────────────────────┘
          |
          | (Imported in app.py)
          v
    ┌──────────────────────────────────────────┐
    │         RUNNING APPLICATION              │
    │  (Flask app.py + Draft Analysis)         │
    └────────┬─────────────────────────────────┘
             |
    ┌────────┴─────────────────────────────────┐
    |                                          |
    v                                          v
 GET DATA                              MATCH DISHES TO KEGS
 from iiko API:                        Using KEG_TO_DISH_MAPPING:
 • Sales transactions
 • DishName: "Brewlok IPA (0,5)"        "Brewlok IPA (0,5)"
 • Store: "Большой пр. В.О"               ↓ (extract_beer_info)
 • Amount: 10 portions                  Clean: "Brewlok IPA"
 • Date: 2025-11-03                       ↓ (lookup in mapping)
                                       Found KEG: "КЕГ Brewlok IPA 20 л"
                                          ↓
                                       Can now get:
                                       • Inventory data
                                       • Cost data
                                       • Performance metrics
```

---

## 🔄 ШАГ ЗА ШАГОМ: Синхронизация в реальном времени

### Сценарий: Клиент заказывает "Brewlok IPA (0,5)"

#### ЭТАП 1: Заказ попадает в систему

```
POS система создаёт запись:
┌──────────────────────────────────┐
│ Дата:        2025-11-03          │
│ Бар:         Большой пр. В.О    │
│ Позиция:     Brewlok IPA (0,5)  │
│ Количество:  1 порция            │
│ Цена:        350 руб             │
└──────────────────────────────────┘
```

#### ЭТАП 2: Данные попадают в iiko OLAP

```
iiko OLAP система регистрирует:
{
  "DishName": "Brewlok IPA (0,5)",
  "DishAmountInt": 1,
  "Store.Name": "Большой пр. В.О",
  "OpenDate.Typed": "2025-11-03T18:30:00",
  "DishDiscountSumInt": 350,
  "ProductCostBase.ProductCost": 120,
  ...
}
```

#### ЭТАП 3: Приложение запрашивает данные

```python
# app.py вызывает:
olap = OlapReports()
olap.connect()
report_data = olap.get_draft_sales_report(
    date_from="2025-10-01",
    date_to="2025-11-03",
    bar_name="Большой пр. В.О"
)
# Получает список транзакций с "Brewlok IPA (0,5)"
```

#### ЭТАП 4: Парсинг названия пива (extract_beer_info)

```python
# core/draft_analysis.py:
def extract_beer_info(self, dish_name):
    # Input: "Brewlok IPA (0,5)"

    pattern = r'\((\d+[,\.]\d+)\)'
    match = re.search(pattern, dish_name.strip())

    if match:
        volume_str = match.group(1).replace(',', '.')  # "0.5"
        volume = float(volume_str)                      # 0.5
        beer_name = dish_name[:match.start()].strip()  # "Brewlok IPA"

        return beer_name, volume

    # Output: ("Brewlok IPA", 0.5)
```

#### ЭТАП 5: Расчёт объёма

```python
# core/draft_analysis.py (prepare_draft_data):

beer_name = "Brewlok IPA"
portions = 1
portion_volume = 0.5

volume_in_liters = portions * portion_volume  # 1 * 0.5 = 0.5L

# DataFrame после подготовки:
#  BeerName       | PortionVolume | DishAmountInt | VolumeInLiters
#  Brewlok IPA    | 0.5           | 1             | 0.5
```

#### ЭТАП 6: Соответствие кегу (через мэппинг)

```python
# mapping/keg_mapping.py содержит:
KEG_TO_DISH_MAPPING = {
    'КЕГ Brewlok IPA 20 л': ['Brewlok IPA', 'ВО Brewlok IPA'],
    ...
}

# Значит:
# "Brewlok IPA" → "КЕГ Brewlok IPA 20 л"
# Мы знаем, что:
# - Это кег объёмом 20л (стандартный размер)
# - Можем теперь получить cost, остаток в инвентаре, и т.д.
```

#### ЭТАП 7: Агрегирование и аналитика

```
Все продажи "Brewlok IPA" за период:
┌─────────────────────────────────────────────────┐
│ BeerName:           Brewlok IPA                 │
│ Bar:                Большой пр. В.О            │
│ Total Portions:     150 порций                  │
│ Portion Size:       0.5L (в среднем)            │
│ Total Liters:       75L                         │
│ Kegs (30L each):    2.5 кега                    │
│ Total Revenue:      52,500 руб                  │
│ BeerSharePercent:   3.2% от всех проливов     │
│ ABC Category:       B (средняя важность)       │
│ XYZ Category:       X (стабильные продажи)     │
└─────────────────────────────────────────────────┘
```

---

## 🔍 ПОДРОБНЫЙ РАЗБОР МЭППИНГА

### Структура CSV исходного файла

```
KEG_NAME                          | DISH_NAME              | NOTES
────────────────────────────────────────────────────────────────────
КЕГ Brewlok IPA 20 л             | Brewlok IPA            | Основное
КЕГ Brewlok IPA 20 л             | ВО Brewlok IPA         | Во Время вариант
КЕГ ФестХаус Хеллес 30 л         | ФестХаус Хеллес        | Основное
КЕГ Блек Шип 50 л                | Блек Шип               | Основное
КЕГ DaDa сидр #1 сухой 30л       | DaDa сидр #1 сухой    | Основное
КЕГ DaDa сидр #1 сухой 30л       | ВО DaDa сидр #1 сухой | Вариант
```

**Ключевые моменты:**
- Один кег → Несколько блюд (варианты с префиксами)
- Блюда БЕЗ объёма в скобках (парсятся отдельно)
- Кеги С объёмом в названии (20л, 30л, 50л)

### Как Python генерирует мэппинг

```python
# utils/import_final_mapping.py читает CSV и создаёт:

KEG_TO_DISH_MAPPING = {
    'КЕГ Brewlok IPA 20 л': [
        'Brewlok IPA',      # из строки 1 CSV
        'ВО Brewlok IPA'    # из строки 2 CSV
    ],
    'КЕГ ФестХаус Хеллес 30 л': [
        'ФестХаус Хеллес'   # из строки 3 CSV
    ],
    'КЕГ Блек Шип 50 л': [
        'Блек Шип'          # из строки 4 CSV
    ],
    ...
}
```

---

## 🚀 ПОЛНЫЙ ЖИЗНЕННЫЙ ЦИКЛ ПРОДАЖИ

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. КЛИЕНТ ЗАКАЗЫВАЕТ ПИВО                                           │
│    "Один Brewlok IPA (0,5) пожалуйста"                              │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 2. POS СИСТЕМА РЕГИСТРИРУЕТ ПРОДАЖУ                                 │
│    DishName="Brewlok IPA (0,5)", DishAmountInt=1, DishPrice=350      │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 3. iiko OLAP СОХРАНЯЕТ В ОТЧЁТЕ                                     │
│    Экспортирует в OLAP репозиторий для анализа                      │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 4. ПРИЛОЖЕНИЕ ЗАПРАШИВАЕТ ДАННЫЕ                                    │
│    olap.get_draft_sales_report(date_from, date_to, bar_name)       │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 5. ПАРСИНГ НАЗВАНИЯ ПИВА                                            │
│    "Brewlok IPA (0,5)" → extract_beer_info()                        │
│    Результат: ("Brewlok IPA", 0.5)                                  │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 6. РАСЧЁТ ОБЪЁМА                                                     │
│    VolumeInLiters = DishAmountInt * PortionVolume                   │
│    = 1 * 0.5 = 0.5L                                                 │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 7. ПОИСК В МЭППИНГЕ                                                  │
│    "Brewlok IPA" → KEG_TO_DISH_MAPPING                              │
│    Ищет в значениях (списках блюд) и находит:                      │
│    "КЕГ Brewlok IPA 20 л" (кег содержит такое блюдо)              │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 8. АГРЕГИРОВАНИЕ ПО ПИВУ И БАРУ                                     │
│    Группируем все продажи "Brewlok IPA" в баре                     │
│    за выбранный период (например, 30 дней)                         │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 9. ВЫЧИСЛЕНИЕ МЕТРИК                                                │
│    • TotalLiters = SUM(VolumeInLiters)                             │
│    • TotalPortions = SUM(DishAmountInt)                            │
│    • WeeksActive = COUNT(DISTINCT Week)                           │
│    • AvgLitersPerWeek = TotalLiters / WeeksActive                 │
│    • BeerSharePercent = TotalLiters / SUM(ALL TotalLiters) * 100  │
│    • Kegs30L = TotalLiters / 30                                   │
│    • Kegs50L = TotalLiters / 50                                   │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 10. ABC/XYZ АНАЛИЗ                                                  │
│     • ABC: Ранжирование по доле (80/15/5 правило)                 │
│     • XYZ: Анализ стабильности (коэффициент вариации)             │
│     • Результат: ABC-XYZ комбинация (напр., "AAX")                │
└────────────────────┬────────────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────────────┐
│ 11. ОТОБРАЖЕНИЕ НА СТРАНИЦЕ "ПРОЛИВЫ"                               │
│                                                                      │
│  Brewlok IPA (Большой пр. В.О)                                      │
│  ├─ TotalLiters: 75.0 L                                            │
│  ├─ TotalPortions: 150 порций                                      │
│  ├─ BeerSharePercent: 3.2%  ← ДОЛЯ от всех проливов               │
│  ├─ AvgLitersPerWeek: 15.0 L/неделю                               │
│  ├─ Kegs30L: ~2.5 кега                                            │
│  ├─ ABC_Combined: "B" (важное пиво)                               │
│  └─ XYZ_Category: "X" (стабильное)                                │
└──────────────────────────────────────────────────────────────────────┘
```

---

## 🔐 СИНХРОНИЗАЦИЯ НАЗВАНИЙ: Как избежать рассинхрона?

### Сценарий 1: Новое блюдо добавлено в меню

```
Ситуация: В меню добавили новое блюдо "Craft Brewlok IPA (0,5)"
          но его нет в мэппинге

Что происходит:
① Клиент заказывает "Craft Brewlok IPA (0,5)"
② Парсится как ("Craft Brewlok IPA", 0.5) ✓
③ Ищется в KEG_TO_DISH_MAPPING
④ НЕ НАЙДЕНО ❌
⑤ В базе данных остаётся объём, но без привязки к кегу
⑥ Проблема: Неясно, из какого кега это пиво

Решение: Запустить проверку и обновить мэппинг
python utils/check_unmapped_dishes.py  # → найдёт "Craft Brewlok IPA"
python utils/auto_add_new_dishes.py    # → попробует найти кег автоматически
python utils/import_final_mapping.py   # → обновит mapping/keg_mapping.py
```

### Сценарий 2: Изменили название в POS

```
Было: "Brewlok IPA (0,5)"
Стало: "Brewlok India Pale Ale (0,5)"

Что происходит:
① Парсится как ("Brewlok India Pale Ale", 0.5)
② Ищется в мэппинге
③ НЕ НАЙДЕНО (там ещё старое "Brewlok IPA") ❌
④ Объём считается, но нет связи с кегом

Решение: Обновить CSV мэппинга или переименовать в мэппинге
# В CSV исходном файле:
# КЕГ Brewlok IPA 20 л | Brewlok India Pale Ale
python utils/import_final_mapping.py  # переимпортировать
```

### Сценарий 3: Изменили объём порции в POS

```
Было: "Brewlok IPA (0,5)"
Стало: "Brewlok IPA (0,75)" из-за смены стакана

Что происходит:
① Парсится как ("Brewlok IPA", 0.75) ✓ (правильно!)
② Ищется в мэппинге
③ НАЙДЕНО ("Brewlok IPA") ✓
④ Объём рассчитывается: 0.75L вместо 0.5L ✓
⑤ Автоматически учитывается! ✓ (не требует обновления мэппинга)

Это работает потому что: Мэппинг ищет имя пива БЕЗ объёма
```

---

## 📊 ПРИМЕР РЕАЛЬНЫХ ДАННЫХ

### Транзакции из iiko OLAP

```
DishName                    | DishAmountInt | Store.Name         | OpenDate.Typed
────────────────────────────────────────────────────────────────────────────────
Brewlok IPA (0,5)           | 1             | Большой пр. В.О   | 2025-11-03 18:30
ВО Brewlok IPA (0,5)        | 2             | Лиговский         | 2025-11-03 19:15
Brewlok IPA (0,25)          | 1             | Кременчугская     | 2025-11-03 20:00
Brewlok IPA                 | 3             | Варшавская        | 2025-11-03 20:30
```

### После парсинга (extract_beer_info)

```
BeerName              | PortionVolume | DishAmountInt | VolumeInLiters
────────────────────────────────────────────────────────────────────────
Brewlok IPA           | 0.5           | 1             | 0.5
Brewlok IPA           | 0.5           | 2             | 1.0
Brewlok IPA           | 0.25          | 1             | 0.25
Brewlok IPA           | 0.0 ⚠️        | 3             | 0.0 ⚠️ (ERROR!)
```

**Проблема:** Последняя строка без объёма → не парсится → 0.0L → потеря данных!

**РЕШЕНИЕ БЫЛО ИСПРАВЛЕНО:**
```python
# Раньше (строгий regex):
pattern = r'^(.+?)\s*\((\d+[,\.]\d+)\)\s*$'
# Требовал конца строки, не парсил "Brewlok IPA"

# Теперь (гибкий regex):
pattern = r'\((\d+[,\.]\d+)\)'
# Ищет объём где угодно, "Brewlok IPA" возвращает (beer_name, 0.0)
# что позволяет обработать частично и записать хотя бы имя пива
```

### После агрегирования

```
BeerName    | Bar            | TotalLiters | TotalPortions | BeerSharePercent
────────────────────────────────────────────────────────────────────────────────
Brewlok IPA | Большой пр.В.О | 0.5         | 1             | 2.1%
Brewlok IPA | Лиговский      | 1.0         | 2             | 4.2%
Brewlok IPA | Кременчугская  | 0.25        | 1             | 1.1%
Brewlok IPA | Варшавская     | 0.0         | 3             | 0.0% ⚠️
────────────────────────────────────────────────────────────────────────────────
            | TOTAL          | 1.75L       | 7             | 7.4%
```

**BeerSharePercent рассчитывается как:**
```
Total пива Brewlok IPA за период: 1.75L
Total ВСЕХ проливов за период: 23.7L (например)
Share = (1.75 / 23.7) * 100 = 7.4%
```

---

## 🎯 ИТОГОВАЯ СИНХРОНИЗАЦИЯ

| Этап | Где происходит | Входные данные | Выход | Статус |
|------|----------------|---|---|---|
| 1. Заказ | POS система | Клиент выбирает напиток | DishName в чеке | 🏪 Внешняя |
| 2. Экспорт | iiko OLAP | Все транзакции | SQL отчёт | 🗄️ Внешняя |
| 3. Парсинг | extract_beer_info() | "Brewlok IPA (0,5)" | ("Brewlok IPA", 0.5) | ✅ **Исправлено!** |
| 4. Расчёт | prepare_draft_data() | Количество + Объём | VolumeInLiters | ✅ Работает |
| 5. Мэппинг | KEG_TO_DISH_MAPPING | "Brewlok IPA" | "КЕГ Brewlok IPA 20л" | ✅ Синхронизировано |
| 6. Агрегирование | get_beer_summary() | Список продаж | BeerSharePercent | ✅ Работает |
| 7. Вывод | HTML/JSON | Аналитика | Страница "Проливы" | ✅ Отображается |

---

## ✅ ПРОВЕРКА: Синхронизирована ли система?

### Чек-лист:

```
[ ] 1. CSV исходный файл актуален?
       Проверить: mapping/tochno prav spisok - active_dishes_to_kegs_CLEAN.csv.csv

[ ] 2. Все новые блюда в мэппинге?
       Запустить: python utils/check_unmapped_dishes.py
       Проверить: NEW_DISHES_TO_ADD.csv пуст?

[ ] 3. KEG_TO_DISH_MAPPING актуален?
       Проверить: Дата в mapping/keg_mapping.py свежая?
       Если нет: python utils/import_final_mapping.py

[ ] 4. JSON мэппинги синхронизированы?
       Проверить: data/keg_mapping.json
       Проверить: data/dish_to_keg_mapping.json
       Если нет: python utils/import_final_mapping.py

[ ] 5. Приложение использует новое мэппинг?
       Результат: Перезагрузить приложение (python app.py)
```

### Команда для полной синхронизации:

```bash
# 1. Обнаружить новые блюда
python utils/check_unmapped_dishes.py

# 2. Автоматически сопоставить кеги
python utils/auto_add_new_dishes.py

# 3. Переимпортировать всё мэппинг
python utils/import_final_mapping.py

# 4. Перезагрузить приложение
python app.py
```

---

## 🚨 ВОЗМОЖНЫЕ РАССИНХРОНЫ И КАК ИХ ИЗБЕЖАТЬ

| Проблема | Причина | Симптом | Решение |
|----------|---------|---------|---------|
| **Новое блюдо не в мэппинге** | Добавили в POS | "Unknown beer" в отчёте | Запустить check_unmapped_dishes |
| **Старое мэппинг в памяти** | Не перезагружено приложение | Видны старые названия | Перезагрузить app.py |
| **0.0L в отчёте** | DishName без объёма | Потеря данных | Исправлен (был баг, теперь работает) |
| **Разные объёмы за дни** | Изменили стакан в POS | TotalLiters не совпадает | Нормально (система учитывает) |
| **Кег в инвентаре но не в мэппинге** | Новый товар в iiko | Не отслеживается | Добавить в CSV вручную |
| **Одно блюдо двум кегам** | Ошибка в CSV | Ошибочная аналитика | Обновить CSV, переимпортировать |

